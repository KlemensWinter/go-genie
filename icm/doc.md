from: https://github.com/SFTtech/openage/blob/master/doc/media/terrain.md#view_icmdat

view_icm.dat

"inverse color map"

=> get best color_palette entry rgb to palette index transformation table with 10 variations of brightness

=> 10 color maps, 32x32x32 lookup table, 1 byte indices. => 10 32 kilobyte structures

brightness variation: use row 0..9

fetches the closest color index in the color_table for a given rgb (3 x 8 bit) value. set each "axis" (the 32 bit position) to the upper 5 bits of r, g, b (shift >> 3) select one row => coordinates in the table:

offset = i * (32^3) + r * 32^2 + g * 32 + b
i == [0,9] = icm index
palette_index = byte_at(offset)

sloped terrain lighting brightness levels 1 ICM: normal/unlit pixels (flat tiles) 9 ICMs: lighting => 4 step of darkening and 4 steps of brightening, 1 neutral. one ICM maps to the 50500 palette the other 9 adjust the pixel brightness.

generating the other ICMs: lighting in HSV color space, modify S and V separately. for each RGB value in the ICM, convert to HSV, multiply (clamped) S and V by modifiers convert the resulting HSV color back to RGB. look up this color by the standard ICM, store back palette indices for the modified light to new ICM.

lighting on sloped tiles: sloped/elevation tiles are dynamically generated by texturemapping flat tile data onto the sloped format filtermaps.dat does that texture mapping operates on the RGB values |> weighted bilinear filtering of the source pixels => to convert the resultant R G B back to a palette_index ==> ICM lookup multiple ICMs: pixel lighting step done in higher quality HSV color, no performance impact: lighting data is precalculated.

ICMs may not contain system reserved colors at the beginning and end of the palette => some colors are not used/present in the ICMs